/* HashMap
 * @author Liu Siwei (liusiwei.yjlo@gmail.com)
 * A hash map implemented using heap
 */

import Heap;

func HashMap(capacity) extends Heap {
	
	/* for building heap */
	// Override
	func _Node() {
		var entry = [];
		var left = null;
		var right = null;
		func toString() {
			var str = "";
			var tempEntry = entry;
			while !$is_empty(tempEntry) {
				str += $head(tempEntry).toString();
				tempEntry = $tail(tempEntry);
			}
			return str;
		}
		return func(){};
	}
	
	/* for storing key value pairs */
	func _Entry(k, v) {
		var key = k;
		var value = v;
		func toString() {
			return "("+key+", "+value+")";
		}
		return func(){};
	}
	
	var _CAPACITY = 63;
	
	// Override
	var _root = _Node();
	
	var _size = 0;
	
	/* initialization */
	func _init() {
		if capacity {
			_CAPACITY = capacity;
		}
	}
	_init();

	func hashCode(str) {
		var hash = 0;
		var chars = $string_to_char_list(str);
		if $is_empty(chars) { return hash; }
		while !$is_empty(chars) {
			var chr = $head(chars);
			hash = ((hash << 5) - hash) + $char_code(chr);
			hash = hash & hash; // Convert to 32bit integer
			chars = $tail(chars);
		}
		return hash % _CAPACITY;
	}
	
	func clear() {
		_root = _Node();
		_size = 0;
	}

	/**
	 * Parameters:
	 *     @param key the hashtable key
	 *     @param value the value
	 * Returns:
	 *     the previous value of the specified key in this hashmap,
	 *     or null if it did not have one
	 */
	func put(key, value) {
		var index = hashCode(key);
		var target = _getNodeByPath(_getPathByIndex(index), true);
		var entries = target.entry;
		while !$is_empty(entries) {
			var entry = $head(entries);
			if entry.key == key {
				// found existing key
				var prev_value = entry.value;
				entry.value = value;
				return prev_value;
			}
			entries = $tail(entries);
		}
		// new key
		target.entry = $pair(_Entry(key, value), target.entry);
		_size++;
		return null;
	}

	func get(key) {
		var index = hashCode(key);
		var target = _getNodeByPath(_getPathByIndex(index), false);
		if target {
			var list = target.entry;
			while !$is_empty(list) {
				if $head(list).key == key {
					return $head(list).value;
				}
				list = $tail(list);
			}
			return null;
		}
		return null;
	}
	
	func remove(key) {
		func deleteFromList(list, key) {
			if $is_empty(list) { return list; }
			if $head(list).key == key {
				_size--;
				return deleteFromList($tail(list), key);
			} else {
				return $pair($head(list), deleteFromList($tail(list), key));
			}
		}
		var index = hashCode(key);
		var target = _getNodeByPath(_getPathByIndex(index), false);
		if target {
			var list = target.entry;
			var foundEntry = null;
			while !$is_empty(list) {
				if $head(list).key == key {
					foundEntry = $head(list);
					target.entry = deleteFromList(target.entry, key);
					return foundEntry.value;
				}
				list = $tail(list);
			}
			return null;
		}
		return null;
	}
	
	func size() {
		return _size;
	}
	
	func toString() {
		var str = "";
		for i in 0..<_CAPACITY {
			var node = _getNodeByPath(_getPathByIndex(i), false);
			if node != null && !$is_empty(node.entry) {
				str += (i + ": " + node.toString() + "\n");
			}
		}
		return str;
	}

	return func(){};
}

/*
var hm = HashMap(7);

hm.put("yjlo", 12);
hm.put("siwei", 24);
hm.put("cn", 36);
hm.put("Singapore", 1);

print(hm.toString());

print(hm.get("yjlo"));
print(hm.get("cn"));

hm.put("siwei", "1992");
hm.remove("abc");
hm.remove("yjlo");
	
print(hm.toString());

print(hm.get("siwei"));
*/
